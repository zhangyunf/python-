#### 一、线程和进程
* #### 1--概念
* 1.1进程：资源分配的最小单元
* 1.2线程：cpu调用的最小单元
* #### 2--区别
* 2.1 线程间内存空间共享，进程间内存空间相互独立
* 2.2 线程切换上下文快，进程切换速度慢
#### 二、全局解释器锁
* Python代码的执行由Python虚拟机(也叫解释器主循环)来控制。CPython在执行多线程的时候并不是线程安全的，所以为了程序的稳定性，加一把全局解释锁，确保任何时候都只有一个Python线程执行。虽然 Python 解释器中可以“运行”多个线程，但在同一时刻只有一个线程在解释器中运行。
#### 三、Thread和Threading区别
* 避免使用thread模块，因为更高级别的threading模块更为先进，对线程的支持更为完善，而且使用thread模块里的属性有可能会与threading出现冲突；其次低级别的thread模块的同步原语很少(实际上只有一个)，而threading模块则有很多；再者，thread模块中当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作，至少threading模块能确保重要的子线程退出后进程才退出。thread模块不支持守护线程，当主线程退出时，所有的子线程不论它们是否还在工作，都会被强行退出。而threading模块支持守护线程，守护线程一般是一个等待客户请求的服务器，如果没有客户提出请求它就在那等着，如果设定一个线程为守护线程，就表示这个线程是不重要的，在进程退出的时候，不用等待这个线程退出。
#### 四、Threading模块
* #### 1--包含对象
* 1.1 Thread执行线程的对象
* 1.2 Lock锁对象
* 1.3 RLock递归锁，是一个线程可以再次拥有已持有的锁对象
* 1.4 Condition条件变量对象，使一个线程等待另一个线程满足特定的条件触发
* 1.5 Event事件对象，普通版的Condition
* 1.6 Semaphore信号量，为线程间共享的资源提供一个“计数器”，计数开始值为设置的值，默认为1
* 1.7 BoundedSemaphore和Semaphore相同，有边界，不能超过设置的值
* 1.8 Timer定时运行的线程对象，定时器
* 1.9 Barrier界限，当达到某一界限后才可以继续执行
* #### 2--模块基本方法
* 2.1 threading.active_count() 返回当前活跃的Thread对象数量。返回值和通过enumerate()返回的列表长度是相等的
* 2.2 threading.current_thread() 返回当前线程对象，对应调用者的控制线程。如果调用者的控制线程不是通过threading模块创建，一个功能受限的虚拟线程被返回
* 2.3 threading.get_ident() 返回当前线程的“线程标识符”。这是一个非0整数，没有特定含义，通常用于索引线程特定数据的字典。线程标识符可以被循环使用
* 2.4 threading.enumerate() 返回当前活跃的所有线程对象的列表。该列表包括精灵线程、被current_thread()创建的虚拟线程对象、和主线程。它不包括终止的线程和还没有启动的线程。
* 2.5 threading.main_thread() 返回主线程对象。在正常情况下，主线程就是Python解释器启动的线程。
* 2.6 threading.settrace(func) 为所有从threading模块启动的线程设置一个trace函数。在每个线程的run()方法被调用前，函数将为每个线程被传递到sys.settrace()。
* 2.7 threading.setprofile(func)为所有从threading模块启动的线程设置一个profile函数。在每个线程的run()方法被调用前，函数将为每个线程被传递到sys.setprofile()
* 2.8 threading.stack_size() 返回当创建一个新线程是使用的线程栈大小，0表示使用平台或配置的默认值。
* #### 3--线程常用方法
* 3.1 start() 启动线程，如果在同一个线程对象上调用超过一次将抛出RuntimeError
* 3.2 join(timeout=None) 等待直到线程结束。这将阻塞当前线程直到join()方法被调用的线程或抛出一个未处理的异常，或者设置的移除时间到达。
* 3.3 name 线程名
* 3.4 getName() setName()
* 3.5 ident 线程标识符
* 3.6 is_alive() 返回线程是否活跃
* #### 4--Lock锁
* 4.1 两种状态：acquire()锁  release() 解锁
* 4.2 acquire(blocking=True, timeout = -1) 当blocking参数为True，将阻塞直到锁被释放，然后获取锁并返回True.当blocking参数为False，将不阻塞。如果已经存在线程获取了锁，调用将立即返回False
* #### 5--RLock锁（递归锁）
* 5.1 一个可重入锁可以被同一个线程请求多次。在内部，它在基元锁的基础上使用了“拥有者线程”和“递归级别”的概念。在锁状态，一些线程拥有锁；在未锁状态，没有线程拥有锁
* #### 6--Condition对象
* 6.1

